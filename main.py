#!/usr/bin/env python3
"""
APK Reverse Engineering Toolkit - Main Entry Point
Professional APK analysis, decompilation, and bypass generation
"""

import os
import sys
import argparse
from pathlib import Path

# Add current directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from real_apk_toolkit import APKToolkit
from bypass_generator import BypassGenerator
from web_interface import app

class APKToolkitLauncher:
    def __init__(self):
        self.default_java = r"C:\Program Files\Eclipse Adoptium\jdk-21.0.8.9-hotspot\bin\java.exe"
        self.default_apktool = r"C:\AndroidReverseTools\apktool\apktool.jar"
        
    def verify_environment(self):
        """Verify Java and APKTool are available"""
        print("üîç Verifying Environment...")
        
        if not os.path.exists(self.default_java):
            print(f"‚ùå Java not found at: {self.default_java}")
            print("   Please install Java JDK or update the path in main.py")
            return False
            
        if not os.path.exists(self.default_apktool):
            print(f"‚ùå APKTool not found at: {self.default_apktool}")
            print("   Please download apktool.jar and place it in the correct directory")
            return False
            
        print("‚úÖ Environment verified")
        return True
        
    def run_cli_analysis(self, apk_path):
        """Run command-line APK analysis"""
        toolkit = APKToolkit(self.default_java, self.default_apktool)
        generator = BypassGenerator()
        
        print(f"\nüì± Analyzing APK: {apk_path}")
        print("=" * 50)
        
        # Get APK info
        info, msg = toolkit.get_apk_info(apk_path)
        if not info:
            print(f"‚ùå {msg}")
            return
            
        print(f"üìä APK Information:")
        print(f"   Size: {info['size_mb']} MB")
        print(f"   Files: {info['file_count']}")
        print(f"   SHA256: {info['sha256'][:16]}...")
        print(f"   Valid APK: {'‚úÖ' if info['has_manifest'] and info['has_classes'] else '‚ùå'}")
        
        # Decompile APK
        output_dir = apk_path.replace('.apk', '_decompiled')
        print(f"\nüîß Decompiling APK...")
        success, msg = toolkit.decompile_apk(apk_path, output_dir)
        
        if not success:
            print(f"‚ùå Decompile failed: {msg}")
            return
            
        print(f"‚úÖ {msg}")
        
        # Find purchase methods
        print(f"\nüîç Searching for purchase methods...")
        methods, msg = toolkit.find_purchase_methods(output_dir)
        
        if methods:
            print(f"‚úÖ {msg}")
            print(f"\nüéØ Found Purchase Methods:")
            for i, method in enumerate(methods[:10], 1):  # Show first 10
                print(f"   {i}. {method['class']}: {method['method']}")
                
            # Generate bypass for first method
            if methods:
                first_method = methods[0]
                print(f"\nüõ†Ô∏è  Generating bypass for: {first_method['method']}")
                
                # Read smali file and analyze
                try:
                    with open(first_method['file'], 'r', encoding='utf-8') as f:
                        content = f.read()
                        
                    analysis, msg = generator.analyze_method_for_bypass(content, first_method['method'])
                    if analysis:
                        bypass_code, msg = generator.generate_bypass(
                            first_method['method'],
                            analysis['signature'],
                            analysis['recommended_bypass']
                        )
                        
                        if bypass_code:
                            print(f"‚úÖ Bypass generated successfully")
                            print(f"\nüìù Generated Bypass Code:")
                            print("-" * 40)
                            print(bypass_code)
                            print("-" * 40)
                        else:
                            print(f"‚ùå Bypass generation failed: {msg}")
                    else:
                        print(f"‚ùå Method analysis failed: {msg}")
                except Exception as e:
                    print(f"‚ùå Error reading method file: {str(e)}")
        else:
            print(f"‚ÑπÔ∏è  {msg}")

    def run_web_interface(self, port=5000, host='0.0.0.0'):
        """Launch web interface"""
        print(f"\nüåê Starting Web Interface...")
        print(f"   URL: http://{host}:{port}")
        print(f"   Press Ctrl+C to stop")
        print("=" * 50)
        
        try:
            app.run(debug=False, host=host, port=port)
        except KeyboardInterrupt:
            print("\nüõë Web interface stopped")

def main():
    parser = argparse.ArgumentParser(description="APK Reverse Engineering Toolkit")
    parser.add_argument("--mode", choices=["cli", "web"], default="web",
                       help="Run mode: cli for command-line, web for web interface")
    parser.add_argument("--apk", type=str, help="APK file path for CLI analysis")
    parser.add_argument("--port", type=int, default=5000, help="Web interface port")
    parser.add_argument("--host", type=str, default="0.0.0.0", help="Web interface host")
    
    args = parser.parse_args()
    
    launcher = APKToolkitLauncher()
    
    print("üöÄ APK Reverse Engineering Toolkit")
    print("=" * 50)
    
    if not launcher.verify_environment():
        print("\n‚ùå Environment verification failed. Please fix the issues above.")
        return 1
        
    if args.mode == "cli":
        if not args.apk:
            print("‚ùå APK file path required for CLI mode. Use --apk <path>")
            return 1
            
        if not os.path.exists(args.apk):
            print(f"‚ùå APK file not found: {args.apk}")
            return 1
            
        launcher.run_cli_analysis(args.apk)
        
    elif args.mode == "web":
        launcher.run_web_interface(args.port, args.host)
        
    return 0

if __name__ == "__main__":
    sys.exit(main())
